<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BennuLib</name>
    </assembly>
    <members>
        <member name="T:Bennu.IO.File">
            <summary>
            Provides static methods for the opening and creation of Bennu native file
            format.
            </summary>
        </member>
        <member name="M:Bennu.IO.File.LoadMap(System.String)">
            <summary>
            Opens a Map file, reads all the information into a <see cref="T:Bennu.Sprite"/> 
            object, and then closes the file.
            </summary>
            <param name="path">The file to open.</param>
            <returns>An instance of <see cref="T:Bennu.Sprite"/> created from the file.</returns>
        </member>
        <member name="M:Bennu.IO.File.SaveMap(Bennu.Sprite,System.String)">
            <summary>
            Creates a new Map file, writes the information of a <see cref="T:Bennu.Sprite"/>,
            and then closes the file. If the target file already exists, it is overwritten.
            </summary>
            <param name="sprite">The <see cref="T:Bennu.Sprite"/> to write to the file.</param>
            <param name="path">The file to write to.</param>
        </member>
        <member name="M:Bennu.IO.File.LoadFpg(System.String)">
            <summary>
            Opens a Fpg file, reads all the information into a <see cref="T:Bennu.SpriteAsset"/> 
            object, and then closes the file.
            </summary>
            <param name="path">The file to open.</param>
            <returns>An instance of <see cref="T:Bennu.SpriteAsset"/> created from the file.</returns>
        </member>
        <member name="M:Bennu.IO.File.SaveFpg(Bennu.SpriteAsset,System.String)">
            <summary>
            Creates a new Fpg file, writes the information of a <see cref="T:Bennu.SpriteAsset"/>,
            and then closes the file. If the target file already exists, it is overwritten.
            </summary>
            <param name="asset">The <see cref="T:Bennu.SpriteAsset"/> to write to the file.</param>
            <param name="path">The file to write to.</param>
        </member>
        <member name="M:Bennu.IO.File.LoadPal(System.String)">
            <summary>
            Opens a 8bpp Pal, Map, Fpg or Fnt file, reads all the information into 
            a <see cref="T:Bennu.Palette"/> object, and then closes the file.
            </summary>
            <param name="path">The file to open.</param>
            <returns>An instance of <see cref="T:Bennu.Palette"/> created from the file.</returns>
        </member>
        <member name="M:Bennu.IO.File.SavePal(Bennu.Palette,System.String)">
            <summary>
            Creates a new Pal file, writes the information of a <see cref="T:Bennu.Palette"/>,
            and then closes the file. If the target file already exists, it is overwritten.
            </summary>
            <param name="palette">The <see cref="T:Bennu.Palette"/> to write to the file.</param>
            <param name="path">The file to write to.</param>
        </member>
        <member name="T:Bennu.IO.FntAbstractFontDecoder">
            <summary>
            Bennu supports two types of font formats: Bennu's own format, called 'Fnx' Fonts, and
            the legacy DIV Games Studio font format, called 'Fnt'. 
            Much of the process of decoding those formats is equivalent. This class 
            </summary>
        </member>
        <member name="T:Bennu.IO.NativeDecoder`1">
            <summary>
            <see cref="T:Bennu.IO.NativeDecoder`1"/> base class for all native formats decoders. It defines
            common behaviour and defines a set of template methods that derivated classes must
            implement.
            </summary>
            <remarks>
            All native formats for fonts, graphics, graphic collections and palettes have 
            similarities in how they are read from disk:
            <list type="bullet">
                <item>Might or might not be compressed in GZip format</item>
                <item>Have a magic indicating the type of the file</item>
                <item>Have an specific sequence of bytes called terminator</item>
                <item>Have a byte indicating the version of the file</item>
            </list>
            The <see cref="T:Bennu.IO.NativeDecoder`1"/> takes care of the communalities and leave the
            read of the body to the derivated classes.
            </remarks>
            <typeparam name="T">The </typeparam>
        </member>
        <member name="P:Bennu.IO.NativeDecoder`1.MaxSupportedVersion">
            <summary>
            The highest version number that the decoder expects to be capable of reading.
            </summary>
        </member>
        <member name="M:Bennu.IO.NativeDecoder`1.ReadBody(Bennu.IO.NativeFormat.Header,Bennu.IO.NativeFormatReader)">
            <summary>
            Decodes the body of the native format and returns a <see cref="N:Bennu"/> base 
            type.
            </summary>
            <param name="header">A header object containing information of the magic, terminator
            and version.</param>
            <param name="reader">A <see cref="T:Bennu.IO.NativeFormatReader"/> that is used to read the
            stream</param>
            <returns></returns>
        </member>
        <member name="P:Bennu.IO.NativeDecoder`1.KnownFileMagics">
            <summary>
            The list of magic
            </summary>
        </member>
        <member name="P:Bennu.IO.NativeDecoder`1.KnownFileExtensions">
            <summary>
            The list of extensions that the Decoder expects to be capable of reading.
            </summary>
        </member>
        <member name="M:Bennu.IO.NativeDecoder`1.HeaderIsGZip(System.Byte[])">
            <summary>
            GZip files start always with bytes {31, 139}. This function
            will check if the argument matches that criteria.
            </summary>
            <param name="header">An array of bytes containing at least two elements</param>
            <returns>True if the first two bytes <paramref name="header"/> are 
            that of GZip format.</returns>
        </member>
        <member name="M:Bennu.IO.NativeDecoder`1.Decode(System.IO.Stream)">
            <summary>
            Decodes the stream and returns a <see cref="N:Bennu"/> base type.
            </summary>
            <param name="input">The stream from which to read.</param>
            <returns>A <see cref="N:Bennu"/> base type.</returns>
        </member>
        <member name="M:Bennu.IO.NativeDecoder`1.TryDecode(System.IO.Stream,`0@)">
            <summary>
            Attempts to decode <paramref name="input"/> into <paramref name="decoded"/>.
            Returns whether the operation succeded or not.
            </summary>
            <param name="input">The input from which to read.</param>
            <param name="decoded">When this method returns, the result of decoding the 
            <see cref="T:System.IO.Stream"/>. If the decoding fails, <paramref name="decoded"/> will
            contain the default value of <typeparamref name="T"/>.</param>
            <returns>True if the decoding was successful. Otherwise false.</returns>
        </member>
        <member name="M:Bennu.IO.NativeDecoder`1.ConcatenatedStream.#ctor(System.IO.Stream,System.IO.Stream)">
            <summary>
            
            </summary>
            <param name="stream1">Stream1 needs to support the Length property and it
            cannot be longer than sizeof(int). Stream 2</param>
            <param name="stream2"></param>
        </member>
        <member name="P:Bennu.IO.ExtendedFntFontDecoder.MaxSupportedVersion">
            <summary>
            Extended fonts (fnx) fonts do not have a version byte so this information is not used.
            </summary>
        </member>
        <member name="M:Bennu.IO.ExtendedFntFontDecoder.ValidateHeaderVersion(System.Int32,Bennu.IO.NativeFormat.Header)">
            <summary>
            Validates the version information of the <paramref name="header"/>. Extended fonts
            do not store version information and therefore this function always returns True.
            </summary>
            <param name="version"></param>
            <param name="header"></param>
            <returns>True</returns>
        </member>
        <member name="F:Bennu.IO.NativeFormat.PaletteBytesSize">
            <summary>
            The size of the color palette area, in bytes
            </summary>
        </member>
        <member name="F:Bennu.IO.NativeFormat.ReservedBytesSize">
            <summary>
            The size of the gamma color area, in bytes
            </summary>
        </member>
        <member name="F:Bennu.IO.NativeFormat.PivotPointsNumberBitMask">
            <summary>
            Bit mask used to separate the number of pivot points from the animation flags
            </summary>
        </member>
        <member name="F:Bennu.IO.NativeFormat.AnimationFlagBitMask">
            <summary>
            Bit mask used to get the animation bit flag. Animation is not supported.
            </summary>
        </member>
        <member name="T:Bennu.IO.NativeFormat.Header">
            <summary>
            Represents the header of the native formats, i.e. a section describing type
            type of file (graphic, graphic collection, font or palettes), and the depth
            of the graphic information (1, 8, 16 or 32bpp).
            </summary>
        </member>
        <member name="P:Bennu.IO.NativeFormat.Header.Depth">
            <summary>
            All native format's magic follow the pattern 'aXY' where XY indicates, for
            non 8bpp formats, the depth (01, 16 or 32). For 8bpp formats, XY ar two 
            characters.
            </summary>
        </member>
        <member name="P:Bennu.IO.NativeFormat.GlyphInfo.Width">
            <summary>
            The width of the character's glyph
            </summary>
        </member>
        <member name="P:Bennu.IO.NativeFormat.GlyphInfo.Height">
            <summary>
            The height of the characters's glyph
            </summary>
        </member>
        <member name="P:Bennu.IO.NativeFormat.GlyphInfo.XOffset">
            <summary>
            Displacement in the x-axis from the left side
            </summary>
        </member>
        <member name="P:Bennu.IO.NativeFormat.GlyphInfo.YOffset">
            <summary>
            Displacement in the Y-axis from the top side
            </summary>
        </member>
        <member name="P:Bennu.IO.NativeFormat.GlyphInfo.XAdvance">
            <summary>
            
            </summary>
        </member>
        <member name="P:Bennu.IO.NativeFormat.GlyphInfo.YAdvance">
            <summary>
            
            </summary>
        </member>
        <member name="P:Bennu.IO.NativeFormat.GlyphInfo.FileOffset">
            <summary>
            The byte-location of the glyph's graphic data (pixels) in the
            file.
            </summary>
        </member>
        <member name="M:Bennu.IO.NativeFormat.GlyphInfo.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="width"></param>
            <param name="height"></param>
            <param name="yOffset"></param>
            <param name="fileOffset"></param>
        </member>
        <member name="M:Bennu.IO.NativeFormat.GlyphInfo.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="width"></param>
            <param name="height"></param>
            <param name="xOffset"></param>
            <param name="yOffset"></param>
            <param name="xAdvance"></param>
            <param name="yAdvance"></param>
            <param name="fileOffset"></param>
        </member>
        <member name="T:Bennu.Sprite">
             <summary>
             A sprite is SpritePocket concept of image data (pixel information) and
             pivot points information grouped.
            
             Sprites can be collected in <see cref="T:Bennu.SpriteAsset"></see>s and given a code from which
             it is possible to be retrieved later on.
             </summary>
        </member>
        <member name="P:Bennu.Sprite.Width">
            <summary>
            The width.
            </summary>
            <returns>The width in pixels.</returns>
        </member>
        <member name="P:Bennu.Sprite.Height">
            <summary>
            The height.
            </summary>
            <returns>The height in pixels.</returns>
        </member>
        <member name="P:Bennu.Sprite.Id">
            <summary>
            The <see cref="T:Bennu.Sprite"/> identifier.
            </summary>
            <returns>The identifier of this <see cref="T:Bennu.Sprite"/> within its
            parent <see cref="T:Bennu.SpriteAsset"/>. <c>Nothing</c> if this object
            is not contained in the <see cref="T:Bennu.SpriteAsset"/></returns>
        </member>
        <member name="P:Bennu.Sprite.Description">
            <summary>
            A descriptive string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Bennu.Sprite.IsPivotPointDefined(System.Int32)">
            <summary>
            Checks if a pivot point id has been defined.
            </summary>
            <param name="id">the id of the pivot point</param>
            <returns>True if the pivot point has been defined.</returns>
        </member>
    </members>
</doc>
